<h1><code ng:non-bindable=""></code>
<span class="hint"></span>
</h1>
<div><h2 id="overview">Overview</h3>

<h3 id="goal">Goal</h4>

<p>The goal of this SDK is to make the FamilySearch REST endpoints easier to consume.
Each SDK function wraps a corresponding REST endpoint and adds <em>convenience functions</em>
to make navigating the response easier.
In addition to the convenience functions you also have access to the original response,
so you always have the option of navigating the response elements yourself.
And you can make calls not anticipated by the SDK using the <em>plumbing functions</em> described below.</p>

<h3 id="features">Features</h4>

<ul>
<li>Authentication can be performed with a single function call, or even automatically.</li>
<li>The access token can be saved in a cookie and can be expired automatically.</li>
<li>REST endpoints can be called using simple function calls that set the correct request headers and request the correct URL.</li>
<li>GET's are automatically retried to handle transient errors.</li>
<li>Throttling is handled - calls are automatically retried.</li>
<li>Responses are mapped to objects or arrays of objects that have convenience functions
to make extracting data from the responses easier.</li>
<li>The response object prototypes can be extended with additional functions to navigate the response json and return
whatever custom information is desired.</li>
<li>The SDK works using jQuery, AngularJS, or Node.js; no other dependencies are required.</li>
</ul>

<h3 id="objectmodel">Object model</h4>

<p>Here is a list of objects returned in the SDK function responses</p>

<p>People with names and facts</p>

<ul>
<li><a href="#/api/person.types.type:Person">Person</a></li>
<li><a href="#/api/person.types.type:Fact">Fact</a></li>
<li><a href="#/api/person.types.type:Name">Name</a></li>
</ul>

<p>Relationships between people</p>

<ul>
<li><a href="#/api/person.types.type:Couple">Couple</a></li>
<li><a href="#/api/person.types.type:ChildAndParents">ChildAndParents</a></li>
<li><a href="#/api/person.types.type:ParentChild">ParentChild</a> (will hopefully go away in favor of ChildAndParents)</li>
</ul>

<p>Ojects related to people (and relationships)</p>

<ul>
<li><a href="#/api/notes.types.type:NoteRef">NoteRef</a></li>
<li><a href="#/api/notes.types.type:Note">Note</a></li>
<li><a href="#/api/sources.types.type:SourceRef">SourceRef</a></li>
<li><a href="#/api/sources.types.type:SourceDescription">SourceDescription</a></li>
<li><a href="#/api/sources.types.type:IdSourceRef">IdSourceRef</a></li>
<li><a href="#/api/discussions.types.type:Discussion">Discussion</a></li>
<li><a href="#/api/discussions.types.type:Comment">Comment</a></li>
<li><a href="#/api/memories.types.type:MemoryRef">MemoryRef</a></li>
<li><a href="#/api/memories.types.type:Memory">Memory</a></li>
<li><a href="#/api/changeHistory.types.type:Change">Change</a></li>
</ul>

<p>Search &amp; match</p>

<ul>
<li><a href="#/api/searchAndMatch.types.type:SearchResult">SearchResult</a></li>
</ul>

<p>Users</p>

<ul>
<li><a href="#/api/user.types.type:Agent">Agent</a></li>
<li><a href="#/api/user.types.type:User">User</a></li>
</ul>

<h2 id="gettingstarted">Getting started</h3>

<p>To use the SDK, you need to</p>

<ol>
<li><p>init the SDK; e.g., (<a href="#/api/init.functions:init">all options</a>)
<pre class="prettyprint linenums">
FamilySearch.init({
  app_key: 'YOUR_ACCESS_KEY_GOES_HERE',
  environment: 'sandbox',
  // auth_callback is the URI you registered with FamilySearch.
  // The page does not need to exist. The URI only needs to have
  // the same host and port as the server running your script
  auth_callback: 'REDIRECT_GOES_HERE',
  http_function: jQuery.ajax,
  deferred_function: jQuery.Deferred
});
</pre></li>
<li><p>get an access token; e.g.,
<pre class="prettyprint linenums">
FamilySearch.getAccessToken().then(function(response) {
   // now you have an access token
});
</pre></li>
<li><p>make API calls; e.g.,
<pre class="prettyprint linenums">
FamilySearch.getCurrentUser().then(function(response) {
   // now you have the response
});
</pre></li>
</ol>

<h3 id="example">Example</h4>

<pre class="prettyprint linenums">
FamilySearch.init({
  app_key: 'MY_ACCESS_KEY',
  environment: 'sandbox',
  auth_callback: 'http://localhost/auth',
  http_function: $.ajax,
  deferred_function: $.Deferred,
});

FamilySearch.getAccessToken().then(function(accessToken) {
  FamilySearch.getCurrentUser().then(function(response) {
    var user = response.getUser();
    console.log('Hello '+user.contactName);
  });
});
</pre>

<h2 id="sdkfunctionsreturnpromises">SDK Functions return promises</h3>

<p>As illustrated by the example above, most SDK functions return <em>promises</em>.
Promises are a great way to manage asynchronous code.
A promise has a <code>then(success callback, optional error callback)</code> method into which you pass your
<em>callback functions</em>.
Your <em>success callback function</em> is called once the promise has been fulfilled;
your <em>error callback function</em> is called if the project gets rejected.
For more information about promises, see for example <a href="http://api.jquery.com/deferred.then/">the jQuery deferred.then() documentation</a>.</p>

<p>Promises returned by the SDK are generated by the <code>deferred_function</code> you passed into the <code>init</code> call.
If the promise is fulfilled, it will call your success callback function with a single parameter containing the response data.
If the response is rejected, it will call your error callback function with whatever the <code>http_function</code> passed into the <code>init</code>
call would call it with.</p>

<p>The following functions are also available on the promise</p>

<ul>
<li><code>getResponseHeader(header)</code></li>
<li><code>getAllResponseHeaders()</code></li>
<li><code>getStatusCode()</code></li>
</ul>

<h3 id="examples">Examples</h4>

<h4 id="jquery">jQuery</h5>

<p>Requires jQuery 1.8 or later.</p>

<p>If you pass <code>jQuery.ajax</code> and <code>jQuery.Deferred</code> into the <code>FamilySearch.init</code> call, the returned promises
will have the the methods <a href="http://api.jquery.com/Types/#Promise">described here</a>; for example</p>

<ul>
<li><code>then(function(response) {}, function(jqXHR, textStatus, errorThrown) {})</code></li>
<li><code>done(function(response) {})</code></li>
<li><code>fail(function(jqXHR, textStatus, errorThrown) {})</code></li>
</ul>

<h4 id="angularjs">AngularJS</h5>

<p>If you pass <code>$http</code> and <code>$q.defer</code> into the <code>FamilySearch.init</code> call, the returned promises
will have the methods <a href="http://docs.angularjs.org/api/ng.$q#description_the-promise-api">described here</a>; for example</p>

<ul>
<li><code>then(function(response) {}, function({data: response, status: status, headers: headers, config: config}) {})</code></li>
<li><code>catch(function({data: response, status: status, headers: headers, config: config}) {})</code></li>
</ul>

<h4 id="nodejsnotyetimplemented">Node.js -- not yet implemented</h5>

<h2 id="handlingresponses">Handling responses</h3>

<p>SDK function responses are typically json objects.
The SDK function calls add <em>convenience functions</em> for returning various objects from the response.
For example, the <code>getPerson('ID')</code> call adds a <code>response.getPerson()</code> convenience function that returns the
<a href="#/api/person.types:type.Person">Person</a> object from the response.</p>

<p>The returned objects contain the same properties as the original response json, but they have custom constructors whose
prototypes add convenience functions.
For example, the prototype for <a href="#/api/person.types:type.Person">Person</a> objects includes <code>getGivenName()</code> and <code>getSurname()</code>
convenience functions for returning the person's given name and surname respectively.
Without these convenience functions, you would have to navigate the <code>parts</code> elements of the <code>nameForms</code> array,
look for a part whose <code>type</code> element is <code>http://gedcomx.org/Given</code> or <code>http://gedcomx.org/Surname</code> respectively, and
then return the <code>value</code> element of that part.  <code>getGivenName()</code> and <code>getSurname()</code> do this for you.
The object properties and convenience functions are fully described in the docs.</p>

<p>You can add your own convenience functions to the returned objects.
For example, suppose you wanted to display someone's name followed by their id. You could write
<pre class="prettyprint linenums">
  FamilySearch.Person.prototype.getNameAndId = function() {
    return this.getName() + ' (' + this.id + ')';
  }
</pre>

<p>and from then on you could call <code>person.getNameAndId()</code> on any <a href="#/api/person.types:type.Person">Person</a> object.</p>

<pre class="prettyprint linenums">
FamilySearch.getPerson('ID').then(function(response) {
  var person = response.getPerson();
  console.log('Hello '+person.getNameAndId());
});
</pre>

<h2 id="usingthesdkwithmoduleloaders">Using the SDK with module loaders</h3>

<p>The SDK can be used</p>

<ul>
<li>as a browser global (i.e., referring to it as <code>window.FamilySearch</code> or just <code>FamilySearch</code>),</li>
<li>with AMD loaders like <em>RequireJS</em> (<a href="https://github.com/rootsdev/familysearch-javascript-sdk/blob/master/examples/jquery.html">see the jQuery.html example</a>),</li>
<li>or with CommonJS loaders like <em>Node.js</em> (no example yet).</li>
</ul>

<p>It does this by prepending <a href="https://github.com/rootsdev/familysearch-javascript-sdk/blob/master/src/header.frag">a 40-line header</a>
to the front of the combined file.
This header should work for any project that needs to combine javascript source files located in a single directory
written using the AMD <em>defines</em> format and make them available also for CommonJS or as a browser global.
The header is far less code than using the <a href="https://github.com/jrburke/almond">Almond loader</a>, which is the other approach.</p>

<h2 id="plumbingfunctions">Plumbing functions</h3>

<p>The functions in the <em>plumbing</em> module are low-level functions that you would not normally call.
The higher-level API functions that you normally call are built on top of the plumbing functions.
The plumbing functions are exposed in case you want to do something not anticipated by the API functions.
Promises returned by plumbing functions call their callback functions with whatever the <code>http_function</code>
passed into the <code>init</code> call would call them with.
The plumbing functions serve the same purpose as the
<a href="https://www.kernel.org/pub/software/scm/git/docs/#_low_level_commands_plumbing">plumbing functions in git</a>.</p>

<h2 id="contributing">Contributing</h3>

<p><strong>Pull requests are welcome!</strong></p>

<p><strong>Grunt</strong> We use grunt as our build tool.  Grunt has targets to run jshint, unit tests, generate the HTML documentation,
and combine and minify the javascript source files.
Two of the most useful targets are <code>grunt server</code> which starts a server and watches the source files for changes, and
<code>grunt build</code> which builds everything.</p>

<p><strong>JSHint</strong> We use a fairly strict .jshintrc file. JSHint is a great way to catch potential bugs before they occur.
Please use grunt to run jshint over your files before submitting pull requests.</p>

<p><strong>Unit tests</strong> are created by copying and pasting the sample json responses provided on the FamilySearch
developers website into files in the test/mock directory, then calling the corresponding function and running various
expectations over the results.
A test mock redirects the function call to read the response from the corresponding json file instead of calling the
actual FamilySearch REST API.
Your pull requests should contain unit tests for new functionality and make sure that existing unit tests all pass.</p>

<p><strong>Documentation</strong> is generated from JSDoc comments that have been extended with some <em>ngdoc</em> keywords.
Take a look at the existing code for examples.
Your pull requests should be documented.</p>

<p><strong>Travis-CI</strong> Whenever a push is made to github, Travis-CI calls grunt to run jshint, unit tests, generate the HTML
documentation, combine and minify the javascript source files, and publish the documentation and combined &amp; minified
source to the gh-pages branch on github.</p></div>
